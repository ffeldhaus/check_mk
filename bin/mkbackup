#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import os
import sys
import getopt

# TODO: Clean this up one day by using the way recommended by gettext.
# (See https://docs.python.org/2/library/gettext.html). For this we
# need the path to the locale files here.
try:
    _
except NameError:
    _ = lambda x: x # Fake i18n when not available

def is_root():
    return os.getuid() == 0


def system_config_path():
    return "/etc/cma/backup.conf"


def site_config_path():
    if "OMD_ROOT" not in os.environ:
	raise Exception(_("Not executed in OMD environment!"))
    return "%s/etc/check_mk/backup.mk" % os.environ["OMD_ROOT"]


# Wenn als root ausgeführt:
# - System-Konfiguration laden
# Wenn als Site-User ausgeführt:
# - Targets aus System-Konfiguration laden
# - Site-Konfiguration laden
def load_config():
    def load_file(path):
        return eval(file(path).read())

    if is_root():
        config = load_file(system_config_path())
    else:
        config = load_file(site_config_path())

        system_targets = load_file(system_config_path())["targets"]
        config["targets"].update(system_targets)

    return config

# Es gibt ein globales Backup-Lock, das bei modifizierenden Aktionen
# geholt wird. D.h. es kann Systemweit immer nur ein Backup oder Restore
# zur Zeit ausgeführt werden.

# Parameter:
# - Modus (backup, restore, list, show)
#
#   Backup: Erstellt eine neue Sicherung
#       Als Site-Nutzer wird immer ein Site-Backup der aktuellen Site
#       erstellt. Als root wird ein Systembackup ausgeführt. Per Default
#       sind dabei auch alle Sites mit enthalten.
#   - ID des Backup targets
#   - Optional (als root):
#     - Sites ausschließen
#
#   Beispielbefehle:
#     # Site- oder Systemsicherung:
#     mkbackup backup nfs
#
#     # Systemsicherung ohne Sites:
#     mkbackup backup nfs --without-sites
#
#   List: Alle Backups auflisten
#       Als Site-Nutzer sieht man nur die Site-Backups (auch die, die
#       durch die Systembackups erstellt wurden)
#   - Target-ID
#
#   Beispielbefehle:
#     # listet alle Backups auf die man sehen darf
#     mkbackup list nfs
#
#     # listet alle Backups auf die man sehen darf die zu diesem Job gehören
#     mkbackup list nfs --job=xxx
#
#   Restore:
#   - Target-ID
#   - Backup-ID
#     - Als Site-Nutzer muss man die Backup-ID eines Site-Backups angeben
#
#   Beispielbefehle:
#     # listet alle Backups auf die man sehen darf
#     mkbackup restore nfs backup-id-20
#
#   Show: Zeigt Metainfos zu einem Backup an
#   - Target-ID
#   - Backup-ID
#
#   Beispielbefehle:
#     mkbackup show nfs backup-id-20


modes = {
    "backup": {
	"description": _("Starts creating a new backup"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	],
	"root_opts": {
	    "without-sites": {
		"description": _("Create a system backup but exclude the Check_MK sites."),
	    },
	},
    },
    "restore": {
	"description": _("Starts the restore of a backup"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	    {
		"id": _("Backup-ID"),
		"description": _("The ID of the backup to restore"),
	    },
	],
    },
    "list": {
	"description": _("Output the list of all backups"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	],
    },
    "show": {
	"description": _("Shows information about a backup"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	    {
		"id": _("Backup-ID"),
		"description": _("The ID of the backup to show"),
	    },
	],
    },
}


# TODO: Implement this
def mode_backup(target_id, opts):
    print target_id, opts


# TODO: Implement this
def mode_restore(target_id, backup_id, opts):
    print target_id, backup_id, opts


# TODO: Implement this
def mode_list(target_id, opts):
    print target_id, opts


# TODO: Implement this
def mode_show(target_id, backup_id, opts):
    print target_id, backup_id, opts


def usage(error=None):
    if error:
	sys.stderr.write("ERROR: %s\n" % error)
    sys.stdout.write("Usage: mkbackup [OPTIONS] MODE [MODE_ARGUMENTS...] [MODE_OPTIONS...]\n")
    sys.stdout.write("\n")
    sys.stdout.write("OPTIONS:\n")
    sys.stdout.write("\n")
    sys.stdout.write("    --verbose     Enable verbose output, twice for more details\n")
    sys.stdout.write("    --debug       Let Python exceptions come through\n")
    sys.stdout.write("    --version     Print the version of the program\n")
    sys.stdout.write("\n")
    sys.stdout.write("MODES:\n")
    sys.stdout.write("\n")

    for mode_name, mode in sorted(modes.items()):
        sys.stdout.write("    %-13s %s\n" % (mode_name, mode["description"]))
        sys.stdout.write("\n")
        sys.stdout.write("      MODE ARGUMENTS:\n")
        sys.stdout.write("\n")
        for arg in mode["args"]:
            sys.stdout.write("        %-10s %s\n" % (arg["id"], arg["description"]))
        sys.stdout.write("\n")

        opts = mode_options(mode)
        if opts:
            sys.stdout.write("      MODE OPTIONS:\n")
            sys.stdout.write("\n")

            for opt_id, opt in sorted(opts):
                sys.stdout.write("        %-10s %s\n" % (opt_id, opt["description"]))
            sys.stdout.write("\n")

    sys.stdout.write("\n")
    sys.exit(3)


def mode_options(mode):
    mode_options = mode.get("opts", {}).keys()
    if is_root():
        mode_options += mode.get("root_opts", {}).keys()
    return mode_options


opt_verbose = 0
opt_debug   = False


def main():
    global opt_debug, opt_verbose
    short_options = "h"
    # TODO: Implement handling
    long_options = [ "help", "version", "verbose", "debug" ]

    opts, args = getopt.getopt(sys.argv[1:], short_options, long_options)

    for o, a in opts:
        if o in [ "-h", "--help" ]:
            usage()
        elif o == "--version":
            sys.stdout.write("mkbackup %s\n" % VERSION)
            sys.exit(0)
        elif o == "--verbose":
            opt_verbose += 1
        elif o == "--debug":
            opt_debug = True

    try:
        mode_name = args.pop(0)
    except IndexError:
	usage("Missing operation mode")

    try:
	mode = modes[mode_name]
    except KeyError:
	usage("Invalid operation mode")

    # Validate arguments
    if len(args) != len(mode["args"]):
	usage("Invalid number of arguments for this mode")

    # Load the mode specific options
    mode_opts = getopt.getopt(sys.argv[1:], [], mode_options(mode))[0]

    globals()["mode_%s" % mode_name](*args, opts=dict(opts + mode_opts))


main()
