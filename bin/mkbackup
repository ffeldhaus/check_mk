#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

VERSION = "1.4.0i1"

import os
import getopt
import fcntl
import pprint
import re
import signal
import subprocess
import sys
import time
import traceback

import cmk.daemon as daemon
from cmk.exceptions import MKTerminate, MKGeneralException

# TODO: Clean this up one day by using the way recommended by gettext.
# (See https://docs.python.org/2/library/gettext.html). For this we
# need the path to the locale files here.
try:
    _
except NameError:
    _ = lambda x: x # Fake i18n when not available

g_var_path = "/var/lib/mkbackup"

# Is used to duplicate output from stdout/stderr to a the job log. This
# is e.g. used during "mkbackup backup" to store the output.
class Log(object):
    def __init__(self, fd):
        self.fd  = fd

        if self.fd == 1:
            self.orig  = sys.stdout
            sys.stdout = self
        else:
            self.orig  = sys.stderr
            sys.stderr = self

        self.color_replace = re.compile("\033\[\d{1,2}m", re.UNICODE)


    def __del__(self):
        if self.fd == 1:
            sys.stdout = self.orig
        else:
            sys.stderr = self.orig


    def write(self, data):
        self.orig.write(data)
        add_output(self.color_replace.sub('', data))


    def flush(self):
        self.orig.flush()


g_stdout_log = None
g_stderr_log = None

def start_logging():
    global g_stdout_log, g_stderr_log
    g_stdout_log = Log(1)
    g_stderr_log = Log(2)


def stop_logging():
    global g_stdout_log, g_stderr_log
    g_stdout_log = None
    g_stderr_log = None


def is_root():
    return os.getuid() == 0


def site_id():
    return os.environ.get("OMD_SITE")


def system_config_path():
    return "/etc/cma/backup.conf"


def site_config_path():
    if not site_id():
	raise Exception(_("Not executed in OMD environment!"))
    return "%s/etc/check_mk/backup.mk" % os.environ["OMD_ROOT"]


def acquire_backup_lock():
    global g_backup_lock_f
    g_backup_lock_f = open("%s/mkbackup.lock" % g_var_path, "a+")
    try:
        fcntl.flock(g_backup_lock_f, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        raise MKGeneralException(_("Failed to get the exclusive backup lock. "
                            "Another backup/restore seems to be running."))


# Wenn als root ausgeführt:
# - System-Konfiguration laden
# Wenn als Site-User ausgeführt:
# - Targets aus System-Konfiguration laden
# - Site-Konfiguration laden
def load_config():
    def load_file(path):
        return eval(file(path).read())

    if is_root():
        config = load_file(system_config_path())
    else:
        config = load_file(site_config_path())

        try:
            system_targets = load_file(system_config_path())["targets"]
            config["targets"].update(system_targets)
        except IOError:
            # Not existing system wide config is OK. In this case there
            # are only backup targets from site config available.
            pass

    return config

# Es gibt ein globales Backup-Lock, das bei modifizierenden Aktionen
# geholt wird. D.h. es kann Systemweit immer nur ein Backup oder Restore
# zur Zeit ausgeführt werden.

# Parameter:
# - Modus (backup, restore, list, show)
#
#   Backup: Erstellt eine neue Sicherung
#       Als Site-Nutzer wird immer ein Site-Backup der aktuellen Site
#       erstellt. Als root wird ein Systembackup ausgeführt. Per Default
#       sind dabei auch alle Sites mit enthalten.
#   - ID des Backup jobs 
#   - Optional (als root):
#     - Sites ausschließen
#
#   Beispielbefehle:
#     # Site- oder Systemsicherung:
#     mkbackup backup nfs
#
#     # Systemsicherung ohne Sites:
#     mkbackup backup nfs --without-sites
#
#   List: Alle Backups auflisten
#       Als Site-Nutzer sieht man nur die Site-Backups (auch die, die
#       durch die Systembackups erstellt wurden)
#   - Job-ID
#
#   Beispielbefehle:
#     # listet alle Backups auf die man sehen darf
#     mkbackup list nfs
#
#     # listet alle Backups auf die man sehen darf die zu diesem Job gehören
#     mkbackup list nfs --job=xxx
#
#   Restore:
#   - Job-ID
#   - Backup-ID
#     - Als Site-Nutzer muss man die Backup-ID eines Site-Backups angeben
#
#   Beispielbefehle:
#     # listet alle Backups auf die man sehen darf
#     mkbackup restore nfs backup-id-20
#
#   Show: Zeigt Metainfos zu einem Backup an
#   - Job-ID
#   - Backup-ID
#
#   Beispielbefehle:
#     mkbackup show nfs backup-id-20


modes = {
    "backup": {
	"description": _("Starts creating a new backup"),
	"args": [
	    {
		"id": _("Job-ID"),
		"description": _("The ID of the backup job to work with"),
	    },
	],
	"opts": {
	    "background": {
		"description": _("Fork and execute the program in the background."),
	    },
	},
	"root_opts": {
	    "without-sites": {
		"description": _("Create a system backup but exclude the Check_MK sites."),
	    },
	},
    },
    "restore": {
	"description": _("Starts the restore of a backup"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	    {
		"id": _("Backup-ID"),
		"description": _("The ID of the backup to restore"),
	    },
	],
    },
    "list": {
	"description": _("Output the list of all backups"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	],
    },
    "show": {
	"description": _("Shows information about a backup"),
	"args": [
	    {
		"id": _("Target-ID"),
		"description": _("The ID of the backup target to work with"),
	    },
	    {
		"id": _("Backup-ID"),
		"description": _("The ID of the backup to show"),
	    },
	],
    },
}


def mode_backup(local_job_id, opts):
    acquire_backup_lock()

    global g_job_id
    g_job_id = globalize_job_id(local_job_id)

    if local_job_id not in g_config["jobs"]:
        raise MKGeneralException("This backup job does not exist.")

    global g_job_config
    g_job_config = g_config["jobs"][local_job_id]

    init_new_run()

    if "background" in opts:
        daemon.daemonize()
        save_state({"pid": os.getpid()})

    start_logging()

    success = False
    try:
        save_state({
            "state" : "running",
        })

        do_backup(opts)
        success = True

    except KeyboardInterrupt:
        raise

    except:
        if not opt_debug:
            sys.stderr.write("An exception occured:\n")
            sys.stderr.write(traceback.format_exc())
        else:
            raise

    finally:
        stop_logging()
        save_state({
            "state"    : "finished",
            "finished" : time.time(),
            "success"  : success,
        })


def do_backup(opts):
    if not is_root():
        do_site_backup(opts)
    else:
        do_system_backup(opts)


def do_site_backup(opts, site=None):
    cmd = ["omd", "backup"]

    # When executed as site user, "omd backup" is executed without the site
    # name and always performing backup for the current site. When executed
    # as root, the site argument has to be given and must be handed over to
    # "omd backup".
    if site == None:
        site = site_id()
    else:
        if not is_root():
            raise MKGeneralException("Requested backup of site %s, "
                                     "but not running as root." % site_id)
        cmd.append(site)

    # TODO: Nicht direkt speichern, sondern durch gpg/openssl pipen, wenn
    # Verschlüsselung aktiv ist
    cmd.append(site_backup_path(site))

    # TODO: Create missing directories. Ensure group permissions.

    p = subprocess.Popen(cmd, shell=False, close_fds=True,
                         stdout=open(os.devnull, "w"),
                         stderr=subprocess.PIPE, stdin=open(os.devnull))
    if p.wait() != 0:
        raise MKGeneralException(_("Site backup failed: %s") % p.stderr.read())


def site_backup_path(site_id):
    return "%s/site-%s.tar.gz" % (job_backup_path_during_backup(), site_id)


def job_backup_path_during_backup():
    return "%s-incomplete" % job_backup_path()


def job_backup_path_complete():
    return "%s-complete" % job_backup_path()


def job_backup_path():
    target_ident = g_job_config["target"]
    target_cfg = g_config["targets"][target_ident]

    if target_cfg["remote"][0] != "local":
        raise NotImplementedError()

    target_path = target_cfg["remote"][1]["path"]

    return "%s/%s" % (target_path, g_job_id)


def do_system_backup(opts):
    pass # TODO


def globalize_job_id(local_job_id):
    parts = []
    site = site_id()

    if site:
        parts.append("Check_MK")
    else:
        parts.append("Check_MK_Appliance")

    parts.append("Klappspaten") # TODO

    if site:
        parts.append(site)

    return "-".join([ p.replace("-", "+") for p in parts ])


def init_new_run():
    save_state({
        "state"    : "started",
        "pid"      : os.getpid(),
        "started"  : time.time(),
        "output"   : "",
    }, update=False)


def load_state():
    return eval(file(state_path(g_job_id)).read())


def save_state(new_attrs, update=True):
    if update:
        state = load_state()
    else:
        state = {}
    state.update(new_attrs)

    with open(state_path(g_job_id), "w") as f:
        f.write(pprint.pformat(state)+"\n")


def state_path(job_id):
    return "%s/%s.state" % (g_var_path, job_id)


def add_output(s):
    state = load_state()
    state["output"] += s
    save_state(state, update=False)


# TODO: Implement this
def mode_restore(target_id, backup_id, opts):
    acquire_backup_lock()

    print target_id, backup_id, opts


# TODO: Implement this
def mode_list(target_id, opts):
    print target_id, opts


# TODO: Implement this
def mode_show(target_id, backup_id, opts):
    print target_id, backup_id, opts


def usage(error=None):
    if error:
	sys.stderr.write("ERROR: %s\n" % error)
    sys.stdout.write("Usage: mkbackup [OPTIONS] MODE [MODE_ARGUMENTS...] [MODE_OPTIONS...]\n")
    sys.stdout.write("\n")
    sys.stdout.write("OPTIONS:\n")
    sys.stdout.write("\n")
    sys.stdout.write("    --verbose     Enable verbose output, twice for more details\n")
    sys.stdout.write("    --debug       Let Python exceptions come through\n")
    sys.stdout.write("    --version     Print the version of the program\n")
    sys.stdout.write("\n")
    sys.stdout.write("MODES:\n")
    sys.stdout.write("\n")

    for mode_name, mode in sorted(modes.items()):
        sys.stdout.write("    %-13s %s\n" % (mode_name, mode["description"]))
        sys.stdout.write("\n")
        sys.stdout.write("      MODE ARGUMENTS:\n")
        sys.stdout.write("\n")
        for arg in mode["args"]:
            sys.stdout.write("        %-10s %s\n" % (arg["id"], arg["description"]))
        sys.stdout.write("\n")

        opts = mode_options(mode)
        if opts:
            sys.stdout.write("      MODE OPTIONS:\n")
            sys.stdout.write("\n")

            for opt_id, opt in sorted(opts.items(), key=lambda (k, v): k):
                sys.stdout.write("        --%-12s %s\n" % (opt_id, opt["description"]))
            sys.stdout.write("\n")

    sys.stdout.write("\n")
    sys.exit(3)


def mode_options(mode):
    opts = {}
    opts.update(mode.get("opts", {}))
    if is_root():
        opts.update(mode.get("root_opts", {}))
    return opts


def interrupt_handler(signum, frame):
    raise MKTerminate("Caught signal: %d" % signum)


def register_signal_handlers():
    signal.signal(signal.SIGTERM, interrupt_handler)

g_config    = {}
opt_verbose = 0
opt_debug   = False


def main():
    global opt_debug, opt_verbose, g_config

    register_signal_handlers()

    short_options = "h"
    # TODO: Implement handling
    long_options = [ "help", "version", "verbose", "debug" ]

    opts, args = getopt.getopt(sys.argv[1:], short_options, long_options)

    for o, a in opts:
        if o in [ "-h", "--help" ]:
            usage()
        elif o == "--version":
            sys.stdout.write("mkbackup %s\n" % VERSION)
            sys.exit(0)
        elif o == "--verbose":
            opt_verbose += 1
        elif o == "--debug":
            opt_debug = True

    try:
        mode_name = args.pop(0)
    except IndexError:
	usage("Missing operation mode")

    try:
	mode = modes[mode_name]
    except KeyError:
	usage("Invalid operation mode")

    try:
        g_config = load_config()
    except IOError:
        if opt_debug:
            raise
        raise MKGeneralException("mkbackup is not configured yet.")

    # Load the mode specific options
    mode_opts, mode_args = getopt.getopt(sys.argv[2:], [], mode_options(mode).keys())

    # Validate arguments
    if len(mode_args) != len(mode["args"]):
	usage("Invalid number of arguments for this mode")

    opt_dict = dict([ (k.lstrip("-"), v) for k, v in opts + mode_opts ])

    globals()["mode_%s" % mode_name](*mode_args, opts=opt_dict)


try:
    main()
except MKTerminate, e:
    sys.stderr.write("%s\n" % e)
    sys.exit(1)

except KeyboardInterrupt:
    sys.stderr.write("Terminated.\n")
    sys.exit(0)

except MKGeneralException, e:
    sys.stderr.write("%s\n" % e)
    if opt_debug:
        raise
    sys.exit(3)
